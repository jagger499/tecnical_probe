"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Checkbox = void 0;
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var checkbox_1 = require("@material/checkbox");
var base_1 = require("@rmwc/base");
var ripple_1 = require("@rmwc/ripple");
var foundation_1 = require("./foundation");
/*********************************************************************
 * Events
 *********************************************************************/
/**
 * This is an awful freaking bugfix
 * Basically, MDC decided that patching the native getter and setter
 * on a checkbox would be fun which consequently kills Reacts ability
 * to do the same.
 */
// @ts-ignore
checkbox_1.MDCCheckboxFoundation.prototype.installPropertyChangeHooks_ = function () { };
/** A Checkbox component. */
exports.Checkbox = base_1.createComponent(function Checkbox(props, ref) {
    var _a = foundation_1.useCheckboxFoundation(props), renderToggle = _a.renderToggle, id = _a.id, toggleRootProps = _a.toggleRootProps, rootEl = _a.rootEl, checkboxEl = _a.checkboxEl;
    var children = props.children, className = props.className, label = props.label, style = props.style, indeterminate = props.indeterminate, inputRef = props.inputRef, foundationRef = props.foundationRef, rest = tslib_1.__rest(props, ["children", "className", "label", "style", "indeterminate", "inputRef", "foundationRef"]);
    var checkbox = (react_1.default.createElement(CheckboxRoot, tslib_1.__assign({}, rootEl.props(tslib_1.__assign({ checked: rest.checked, indeterminate: indeterminate }, toggleRootProps)), { ref: base_1.mergeRefs(rootEl.setRef, ref) }),
        react_1.default.createElement("input", tslib_1.__assign({}, checkboxEl.props(tslib_1.__assign(tslib_1.__assign({}, rest), { className: 'mdc-checkbox__native-control' })), { type: "checkbox", ref: base_1.mergeRefs(checkboxEl.setRef, inputRef), id: id })),
        react_1.default.createElement(CheckboxBackground, null),
        react_1.default.createElement(CheckboxRipple, null)));
    return renderToggle(checkbox);
});
/*********************************************************************
 * Bits
 *********************************************************************/
var CheckboxRoot = ripple_1.withRipple({
    surface: false,
    unbounded: true
})(react_1.default.forwardRef(function CheckboxRoot(props, ref) {
    var isDataTable = react_1.useContext(base_1.DataTableContext);
    var isDataTableHeader = react_1.useContext(base_1.DataTableHeadContext);
    var disabled = props.disabled, checked = props.checked, indeterminate = props.indeterminate, rest = tslib_1.__rest(props, ["disabled", "checked", "indeterminate"]);
    var className = base_1.useClassNames(props, [
        'mdc-checkbox',
        {
            'mdc-data-table__row-checkbox': isDataTable && !isDataTableHeader,
            'mdc-data-table__header-row-checkbox': isDataTableHeader,
            'mdc-checkbox--disabled': disabled,
            'mdc-checkbox--selected': checked || indeterminate
        }
    ]);
    return react_1.default.createElement(base_1.Tag, tslib_1.__assign({}, rest, { className: className, ref: ref }));
}));
var CheckboxRipple = react_1.default.memo(function CheckboxRipple() {
    return react_1.default.createElement("div", { className: "mdc-checkbox__ripple" });
});
var CheckboxBackground = react_1.default.memo(function () {
    return (react_1.default.createElement("div", { className: "mdc-checkbox__background" },
        react_1.default.createElement("svg", { className: "mdc-checkbox__checkmark", viewBox: "0 0 24 24" },
            react_1.default.createElement("path", { className: "mdc-checkbox__checkmark-path", fill: "none", stroke: "white", d: "M1.73,12.91 8.1,19.28 22.79,4.59" })),
        react_1.default.createElement("div", { className: "mdc-checkbox__mixedmark" })));
});
