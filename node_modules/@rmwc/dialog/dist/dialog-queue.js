"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDialogQueue = exports.DialogQueue = void 0;
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var dialog_1 = require("./dialog");
var base_1 = require("@rmwc/base");
var textfield_1 = require("@rmwc/textfield");
/** A snackbar queue for rendering messages */
function DialogQueue(_a) {
    var dialogs = _a.dialogs, defaultDialogProps = tslib_1.__rest(_a, ["dialogs"]);
    var _b = tslib_1.__read(react_1.useState(0), 2), setIteration = _b[1];
    var _c = tslib_1.__read(react_1.useState({}), 2), closingDialogs = _c[0], setClosingDialogs = _c[1];
    react_1.useEffect(function () {
        var forceUpdate = function () { return setIteration(function (val) { return val + 1; }); };
        dialogs.on('change', forceUpdate);
        return function () {
            dialogs.off('change', forceUpdate);
        };
    }, [dialogs]);
    var removeDialog = function (evt, dialog) {
        var _a;
        setClosingDialogs(tslib_1.__assign(tslib_1.__assign({}, closingDialogs), (_a = {}, _a[dialog.id] = true, _a)));
        dialog.resolve(evt);
        setTimeout(function () {
            // remove the dialog from our array
            var index = dialogs.array.indexOf(dialog);
            !!~index && dialogs.array.splice(index, 1);
            // remove it from the closing state
            var newClosingDialogs = tslib_1.__assign({}, closingDialogs);
            delete newClosingDialogs[dialog.id];
            setClosingDialogs(newClosingDialogs);
        }, 150);
    };
    // A simple way to show only one at a time
    // We loop through until we find a dialog thats not closing
    // When one is closing, we flip this flag and render all of the other ones in a closed state
    // This ensures we get the proper animations for closing dialogs
    var foundOpen = false;
    return (react_1.default.createElement(react_1.default.Fragment, null, dialogs.array.map(function (dialog) {
        var resolve = dialog.resolve, reject = dialog.reject, id = dialog.id, inputProps = dialog.inputProps, rest = tslib_1.__rest(dialog, ["resolve", "reject", "id", "inputProps"]);
        var rendered = (react_1.default.createElement(dialog_1.SimpleDialog, tslib_1.__assign({}, defaultDialogProps, rest, { key: id, open: !closingDialogs[id] && !foundOpen, onClose: function (evt) {
                removeDialog(evt, dialog);
                dialog.onClose && dialog.onClose(evt);
            } })));
        if (!closingDialogs[id]) {
            foundOpen = true;
        }
        return rendered;
    })));
}
exports.DialogQueue = DialogQueue;
/**
 * A base dialog factory that handle setting up the promise
 * With some consistent behavior
 */
var dialogFactory = function (factory, queue) { return function (dialog) {
    return new Promise(function (resolve, reject) {
        var d = factory(tslib_1.__assign(tslib_1.__assign({ id: base_1.randomId() }, dialog), { resolve: resolve, reject: reject }));
        queue.push(d);
    });
}; };
/**
 * Handle prompt dialogs
 * We have to jump through a few hoops to get the value back out
 */
function PromptBody(_a) {
    var body = _a.body, inputProps = _a.inputProps, apiRef = _a.apiRef;
    var _b = tslib_1.__read(react_1.useState(''), 2), value = _b[0], setValue = _b[1];
    react_1.useEffect(function () {
        apiRef(function () { return value; });
    }, [apiRef, value]);
    return (react_1.default.createElement("div", null,
        !!body && react_1.default.createElement("div", { style: { marginBottom: '1rem' } }, body),
        react_1.default.createElement(textfield_1.TextField, tslib_1.__assign({ style: { width: '100%' }, autoFocus: true }, inputProps, { value: value, onChange: function (evt) {
                setValue(evt.currentTarget.value);
            } }))));
}
var promptFactory = function (dialog) {
    var getValue = function () { return ''; };
    var body = (react_1.default.createElement(PromptBody, { body: dialog.body, inputProps: dialog.inputProps, apiRef: function (_getValue) { return (getValue = _getValue); } }));
    return tslib_1.__assign(tslib_1.__assign({ title: 'Prompt' }, dialog), { body: body, resolve: function (evt) {
            dialog.resolve(evt.detail.action === 'accept' ? getValue() : null);
            getValue = undefined;
        } });
};
/** Alerts */
var alertFactory = function (dialog) { return (tslib_1.__assign(tslib_1.__assign({ title: 'Alert', body: 'You have been alerted!', acceptLabel: 'OK', cancelLabel: null }, dialog), { resolve: function (evt) { return dialog.resolve(evt.detail.action); } })); };
/** Confirm */
var confirmFactory = function (dialog) { return (tslib_1.__assign(tslib_1.__assign({ title: 'Confirm', body: 'Are you sure you want do that?', acceptLabel: 'OK', cancelLabel: 'Cancel' }, dialog), { resolve: function (evt) {
        return dialog.resolve(evt.detail.action === 'accept');
    } })); };
/** Creates a snackbar queue */
exports.createDialogQueue = function () {
    var dialogs = new base_1.ArrayEmitter();
    return {
        dialogs: dialogs,
        alert: dialogFactory(alertFactory, dialogs),
        confirm: dialogFactory(confirmFactory, dialogs),
        prompt: dialogFactory(promptFactory, dialogs)
    };
};
