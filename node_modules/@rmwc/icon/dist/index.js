"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Icon = exports.getIconStrategy = void 0;
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var provider_1 = require("@rmwc/provider");
var base_1 = require("@rmwc/base");
/**
 * Given content, tries to figure out an appropriate strategy for it
 */
var processAutoStrategy = function (content) {
    // check for URLS
    if (typeof content === 'string' && content.includes('/')) {
        return 'url';
    }
    // handle JSX components
    if (react_1.default.isValidElement(content)) {
        return 'component';
    }
    // we don't know what it is, default to ligature for compat with material icons
    return 'ligature';
};
/**
 * Get the actual icon strategy to use
 */
exports.getIconStrategy = function (content, strategy, providerStrategy) {
    strategy = strategy || providerStrategy || 'auto';
    if (strategy === 'auto') {
        return processAutoStrategy(content);
    }
    return strategy;
};
var renderLigature = function (_a) {
    var content = _a.content, rest = tslib_1.__rest(_a, ["content"]);
    return (react_1.default.createElement(IconRoot, tslib_1.__assign({}, rest), content));
};
var renderClassName = function (_a) {
    var content = _a.content, rest = tslib_1.__rest(_a, ["content"]);
    return react_1.default.createElement(IconRoot, tslib_1.__assign({}, rest));
};
var renderUrl = function (_a) {
    var content = _a.content, rest = tslib_1.__rest(_a, ["content"]);
    return (react_1.default.createElement(IconRoot, tslib_1.__assign({}, rest, { style: tslib_1.__assign(tslib_1.__assign({}, rest.style), { backgroundImage: "url(" + content + ")" }) })));
};
var renderComponent = function (_a) {
    var content = _a.content, rest = tslib_1.__rest(_a, ["content"]);
    if (content.type === 'svg') {
        var _b = content.props, children = _b.children, svgRest = tslib_1.__rest(_b, ["children"]);
        return (react_1.default.createElement(IconRoot, tslib_1.__assign({}, svgRest, rest, { tag: "svg" }), children));
    }
    return react_1.default.createElement(IconRoot, tslib_1.__assign({}, rest), content);
};
var iconRenderMap = {
    ligature: renderLigature,
    className: renderClassName,
    url: renderUrl,
    component: renderComponent,
    auto: undefined
};
var buildIconOptions = function (icon) {
    if (react_1.default.isValidElement(icon) || (icon && typeof icon !== 'object')) {
        return {
            icon: icon
        };
    }
    return icon;
};
var IconRoot = react_1.default.forwardRef(function IconRoot(props, ref) {
    return react_1.default.createElement(base_1.Tag, tslib_1.__assign({ tag: "i" }, props, { ref: ref }));
});
/** An Icon component. Most of these options can be set once globally, read the documentation on Provider for more info. */
exports.Icon = base_1.createComponent(function (_a, ref) {
    var _b;
    var icon = _a.icon, rest = tslib_1.__rest(_a, ["icon"]);
    var providerContext = provider_1.useProviderContext();
    // Build icon options object
    var _c = tslib_1.__assign({}, buildIconOptions(icon)), content = _c.icon, strategy = _c.strategy, prefix = _c.prefix, basename = _c.basename, render = _c.render, size = _c.size, optionsRest = tslib_1.__rest(_c, ["icon", "strategy", "prefix", "basename", "render", "size"]);
    // Get provider options
    var _d = providerContext.icon || {}, _e = _d.basename, providerBasename = _e === void 0 ? null : _e, _f = _d.prefix, providerPrefix = _f === void 0 ? null : _f, _g = _d.strategy, providerStrategy = _g === void 0 ? null : _g, _h = _d.render, providerRender = _h === void 0 ? null : _h;
    var contentToUse = content;
    var strategyToUse = exports.getIconStrategy(contentToUse, strategy || null, providerStrategy || null);
    var prefixToUse = prefix || providerPrefix;
    var basenameToUse = basename === undefined ? providerBasename : basename;
    var iconClassName = strategyToUse === 'className' && typeof content === 'string'
        ? "" + String(prefixToUse) + content
        : null;
    var rendererFromMap = !!strategyToUse && iconRenderMap[strategyToUse];
    // For some reason TS thinks the render method will return undefined...
    var renderToUse = strategyToUse === 'custom'
        ? render || providerRender
        : rendererFromMap || null;
    if (!renderToUse) {
        console.error("Icon: rendering not implemented for " + String(strategyToUse) + ".");
        return null;
    }
    var rendered = renderToUse(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, rest), optionsRest), { ref: ref, content: contentToUse, className: base_1.classNames('rmwc-icon', "rmwc-icon--" + strategyToUse, basenameToUse, rest.className, optionsRest.className, iconClassName, (_b = {},
            _b["rmwc-icon--size-" + (size || '')] = !!size,
            _b)) }));
    var childDisplayName = base_1.getDisplayName(rendered.props.children);
    if (childDisplayName.includes('Avatar') ||
        childDisplayName.includes('Icon')) {
        return react_1.default.cloneElement(rendered.props.children, tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, rendered.props.children.props), rendered.props), { ref: ref, 
            // prevents an infinite loop
            children: rendered.props.children.props.children, className: base_1.classNames(rendered.props.className, rendered.props.children.props.className) }));
    }
    return rendered;
});
exports.Icon.displayName = 'Icon';
