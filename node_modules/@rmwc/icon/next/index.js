import { __assign, __rest } from "tslib";
import React from 'react';
import { useProviderContext } from '@rmwc/provider';
import { classNames, Tag, createComponent, getDisplayName } from '@rmwc/base';
/**
 * Given content, tries to figure out an appropriate strategy for it
 */
var processAutoStrategy = function (content) {
    // check for URLS
    if (typeof content === 'string' && content.includes('/')) {
        return 'url';
    }
    // handle JSX components
    if (React.isValidElement(content)) {
        return 'component';
    }
    // we don't know what it is, default to ligature for compat with material icons
    return 'ligature';
};
/**
 * Get the actual icon strategy to use
 */
export var getIconStrategy = function (content, strategy, providerStrategy) {
    strategy = strategy || providerStrategy || 'auto';
    if (strategy === 'auto') {
        return processAutoStrategy(content);
    }
    return strategy;
};
var renderLigature = function (_a) {
    var content = _a.content, rest = __rest(_a, ["content"]);
    return (React.createElement(IconRoot, __assign({}, rest), content));
};
var renderClassName = function (_a) {
    var content = _a.content, rest = __rest(_a, ["content"]);
    return React.createElement(IconRoot, __assign({}, rest));
};
var renderUrl = function (_a) {
    var content = _a.content, rest = __rest(_a, ["content"]);
    return (React.createElement(IconRoot, __assign({}, rest, { style: __assign(__assign({}, rest.style), { backgroundImage: "url(" + content + ")" }) })));
};
var renderComponent = function (_a) {
    var content = _a.content, rest = __rest(_a, ["content"]);
    if (content.type === 'svg') {
        var _b = content.props, children = _b.children, svgRest = __rest(_b, ["children"]);
        return (React.createElement(IconRoot, __assign({}, svgRest, rest, { tag: "svg" }), children));
    }
    return React.createElement(IconRoot, __assign({}, rest), content);
};
var iconRenderMap = {
    ligature: renderLigature,
    className: renderClassName,
    url: renderUrl,
    component: renderComponent,
    auto: undefined
};
var buildIconOptions = function (icon) {
    if (React.isValidElement(icon) || (icon && typeof icon !== 'object')) {
        return {
            icon: icon
        };
    }
    return icon;
};
var IconRoot = React.forwardRef(function IconRoot(props, ref) {
    return React.createElement(Tag, __assign({ tag: "i" }, props, { ref: ref }));
});
/** An Icon component. Most of these options can be set once globally, read the documentation on Provider for more info. */
export var Icon = createComponent(function (_a, ref) {
    var _b;
    var icon = _a.icon, rest = __rest(_a, ["icon"]);
    var providerContext = useProviderContext();
    // Build icon options object
    var _c = __assign({}, buildIconOptions(icon)), content = _c.icon, strategy = _c.strategy, prefix = _c.prefix, basename = _c.basename, render = _c.render, size = _c.size, optionsRest = __rest(_c, ["icon", "strategy", "prefix", "basename", "render", "size"]);
    // Get provider options
    var _d = providerContext.icon || {}, _e = _d.basename, providerBasename = _e === void 0 ? null : _e, _f = _d.prefix, providerPrefix = _f === void 0 ? null : _f, _g = _d.strategy, providerStrategy = _g === void 0 ? null : _g, _h = _d.render, providerRender = _h === void 0 ? null : _h;
    var contentToUse = content;
    var strategyToUse = getIconStrategy(contentToUse, strategy || null, providerStrategy || null);
    var prefixToUse = prefix || providerPrefix;
    var basenameToUse = basename === undefined ? providerBasename : basename;
    var iconClassName = strategyToUse === 'className' && typeof content === 'string'
        ? "" + String(prefixToUse) + content
        : null;
    var rendererFromMap = !!strategyToUse && iconRenderMap[strategyToUse];
    // For some reason TS thinks the render method will return undefined...
    var renderToUse = strategyToUse === 'custom'
        ? render || providerRender
        : rendererFromMap || null;
    if (!renderToUse) {
        console.error("Icon: rendering not implemented for " + String(strategyToUse) + ".");
        return null;
    }
    var rendered = renderToUse(__assign(__assign(__assign({}, rest), optionsRest), { ref: ref, content: contentToUse, className: classNames('rmwc-icon', "rmwc-icon--" + strategyToUse, basenameToUse, rest.className, optionsRest.className, iconClassName, (_b = {},
            _b["rmwc-icon--size-" + (size || '')] = !!size,
            _b)) }));
    var childDisplayName = getDisplayName(rendered.props.children);
    if (childDisplayName.includes('Avatar') ||
        childDisplayName.includes('Icon')) {
        return React.cloneElement(rendered.props.children, __assign(__assign(__assign({}, rendered.props.children.props), rendered.props), { ref: ref, 
            // prevents an infinite loop
            children: rendered.props.children.props.children, className: classNames(rendered.props.className, rendered.props.children.props.className) }));
    }
    return rendered;
});
Icon.displayName = 'Icon';
