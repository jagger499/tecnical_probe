"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useLinearProgressFoundation = void 0;
var tslib_1 = require("tslib");
var react_1 = require("react");
var linear_progress_1 = require("@material/linear-progress");
var base_1 = require("@rmwc/base");
exports.useLinearProgressFoundation = function (props) {
    var _a = base_1.useFoundation({
        props: props,
        elements: { rootEl: true },
        foundation: function (_a) {
            var rootEl = _a.rootEl;
            return new linear_progress_1.MDCLinearProgressFoundation({
                addClass: function (className) { return rootEl.addClass(className); },
                getPrimaryBar: function () {
                    var _a;
                    return (((_a = rootEl.ref) === null || _a === void 0 ? void 0 : _a.querySelector(linear_progress_1.MDCLinearProgressFoundation.strings.PRIMARY_BAR_SELECTOR)) || null);
                },
                forceLayout: function () { var _a; return (_a = rootEl.ref) === null || _a === void 0 ? void 0 : _a.offsetWidth; },
                getBuffer: function () {
                    var _a;
                    return ((_a = rootEl.ref) === null || _a === void 0 ? void 0 : _a.querySelector(linear_progress_1.MDCLinearProgressFoundation.strings.BUFFER_SELECTOR)) || null;
                },
                hasClass: function (className) { return rootEl.hasClass(className); },
                removeClass: function (className) { return rootEl.removeClass(className); },
                setStyle: function (el, styleProperty, value) {
                    el.style[styleProperty] = value;
                }
            });
        }
    }), foundation = _a.foundation, elements = tslib_1.__rest(_a, ["foundation"]);
    var _b = tslib_1.__read(react_1.useState(undefined), 2), determinate = _b[0], setDeterminate = _b[1];
    // progress and determinate
    react_1.useEffect(function () {
        foundation.setProgress(props.progress || 0);
        var isDeterminate = props.progress !== undefined;
        if (isDeterminate !== determinate) {
            foundation.setDeterminate(isDeterminate);
            setDeterminate(isDeterminate);
        }
    }, [props.progress, determinate, foundation]);
    // buffer
    react_1.useEffect(function () {
        foundation.setBuffer(props.buffer || 0);
    }, [props.buffer, foundation]);
    // reversed
    react_1.useEffect(function () {
        foundation.setReverse(!!props.reversed);
    }, [props.reversed, foundation]);
    // closed
    react_1.useEffect(function () {
        props.closed ? foundation.close() : foundation.open();
    }, [props.closed, foundation]);
    return tslib_1.__assign({ foundation: foundation }, elements);
};
