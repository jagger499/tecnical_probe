"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRippleFoundation = void 0;
var tslib_1 = require("tslib");
var react_1 = require("react");
var base_1 = require("@rmwc/base");
var base_2 = require("@rmwc/base");
var ripple_1 = require("@material/ripple");
exports.useRippleFoundation = function (props) {
    var isTouched = react_1.useRef(false);
    var _a = base_1.useFoundation({
        props: props,
        elements: {
            rootEl: true,
            surfaceEl: true
        },
        foundation: function (_a) {
            var rootEl = _a.rootEl, surfaceEl = _a.surfaceEl, getProps = _a.getProps;
            return new ripple_1.MDCRippleFoundation({
                browserSupportsCssVars: function () { return ripple_1.util.supportsCssVariables(window); },
                isUnbounded: function () { return !!getProps().unbounded; },
                isSurfaceActive: function () {
                    if (rootEl.ref) {
                        return base_2.matches(rootEl.ref, ':active');
                    }
                    return false;
                },
                isSurfaceDisabled: function () { return !!getProps().disabled; },
                addClass: function (className) {
                    surfaceEl.addClass(className);
                },
                removeClass: function (className) {
                    surfaceEl.removeClass(className);
                },
                containsEventTarget: function (target) {
                    return !!rootEl.ref && rootEl.ref.contains(target);
                },
                registerInteractionHandler: function (evtType, handler) { },
                deregisterInteractionHandler: function (evtType, handler) { },
                registerDocumentInteractionHandler: function (evtType, handler) {
                    return document.documentElement.addEventListener(evtType, handler, { passive: true });
                },
                deregisterDocumentInteractionHandler: function (evtType, handler) {
                    return document.documentElement.removeEventListener(evtType, handler);
                },
                registerResizeHandler: function (handler) { return window.addEventListener('resize', handler); },
                deregisterResizeHandler: function (handler) { return window.removeEventListener('resize', handler); },
                updateCssVariable: function (varName, value) {
                    return surfaceEl.setStyle(varName, value);
                },
                computeBoundingRect: function () {
                    return rootEl.ref ? rootEl.ref.getBoundingClientRect() : base_1.emptyClientRect;
                },
                getWindowPageOffset: function () { return ({
                    x: window.pageXOffset,
                    y: window.pageYOffset
                }); }
            });
        }
    }), foundation = _a.foundation, elements = tslib_1.__rest(_a, ["foundation"]);
    var rootEl = elements.rootEl;
    var activateRipple = react_1.useCallback(function (evt) {
        // https://reactjs.org/docs/events.html#event-pooling
        evt.persist();
        foundation.activate(evt);
    }, [foundation]);
    var deactivateRipple = react_1.useCallback(function (evt) {
        // https://reactjs.org/docs/events.html#event-pooling
        evt.persist();
        foundation.deactivate();
    }, [foundation]);
    var handleFocus = react_1.useCallback(function (evt) {
        var _a;
        (_a = props.onFocus) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        foundation.handleFocus();
    }, [foundation, props.onFocus]);
    var handleBlur = react_1.useCallback(function (evt) {
        var _a;
        (_a = props.onBlur) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        foundation.handleBlur();
    }, [foundation, props.onBlur]);
    var handleMouseDown = react_1.useCallback(function (evt) {
        var _a;
        (_a = props.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        if (!isTouched.current) {
            activateRipple(evt);
        }
        isTouched.current = false;
    }, [props.onMouseDown, activateRipple]);
    var handleMouseUp = react_1.useCallback(function (evt) {
        var _a;
        (_a = props.onMouseUp) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        deactivateRipple(evt);
    }, [props.onMouseUp, deactivateRipple]);
    var handleTouchStart = react_1.useCallback(function (evt) {
        var _a;
        isTouched.current = true;
        (_a = props.onTouchStart) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        activateRipple(evt);
    }, [props.onTouchStart, activateRipple]);
    var handleTouchEnd = react_1.useCallback(function (evt) {
        var _a;
        (_a = props.onTouchEnd) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        deactivateRipple(evt);
    }, [props.onTouchEnd, deactivateRipple]);
    var handleKeyDown = react_1.useCallback(function (evt) {
        var _a;
        (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        activateRipple(evt);
    }, [props.onKeyDown, activateRipple]);
    var handleKeyUp = react_1.useCallback(function (evt) {
        var _a;
        (_a = props.onKeyUp) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        deactivateRipple(evt);
    }, [props.onKeyUp, deactivateRipple]);
    rootEl.setProp('onFocus', handleFocus, true);
    rootEl.setProp('onBlur', handleBlur, true);
    rootEl.setProp('onMouseDown', handleMouseDown, true);
    rootEl.setProp('onMouseUp', handleMouseUp, true);
    rootEl.setProp('onTouchStart', handleTouchStart, true);
    rootEl.setProp('onTouchEnd', handleTouchEnd, true);
    rootEl.setProp('onKeyDown', handleKeyDown, true);
    rootEl.setProp('onKeyUp', handleKeyUp, true);
    react_1.useEffect(function () {
        rootEl.setRef(props.domNode);
    }, [rootEl, props.domNode]);
    react_1.useEffect(function () {
        foundation.setUnbounded(!!props.unbounded);
    }, [props.unbounded, foundation]);
    react_1.useEffect(function () {
        props.disabled && foundation.handleBlur();
    }, [props.disabled, foundation]);
    return tslib_1.__assign({}, elements);
};
