import { __assign, __rest } from "tslib";
import { useCallback, useRef, useEffect } from 'react';
import { useFoundation, emptyClientRect } from '@rmwc/base';
import { matches } from '@rmwc/base';
import { MDCRippleFoundation, util } from '@material/ripple';
export var useRippleFoundation = function (props) {
    var isTouched = useRef(false);
    var _a = useFoundation({
        props: props,
        elements: {
            rootEl: true,
            surfaceEl: true
        },
        foundation: function (_a) {
            var rootEl = _a.rootEl, surfaceEl = _a.surfaceEl, getProps = _a.getProps;
            return new MDCRippleFoundation({
                browserSupportsCssVars: function () { return util.supportsCssVariables(window); },
                isUnbounded: function () { return !!getProps().unbounded; },
                isSurfaceActive: function () {
                    if (rootEl.ref) {
                        return matches(rootEl.ref, ':active');
                    }
                    return false;
                },
                isSurfaceDisabled: function () { return !!getProps().disabled; },
                addClass: function (className) {
                    surfaceEl.addClass(className);
                },
                removeClass: function (className) {
                    surfaceEl.removeClass(className);
                },
                containsEventTarget: function (target) {
                    return !!rootEl.ref && rootEl.ref.contains(target);
                },
                registerInteractionHandler: function (evtType, handler) { },
                deregisterInteractionHandler: function (evtType, handler) { },
                registerDocumentInteractionHandler: function (evtType, handler) {
                    return document.documentElement.addEventListener(evtType, handler, { passive: true });
                },
                deregisterDocumentInteractionHandler: function (evtType, handler) {
                    return document.documentElement.removeEventListener(evtType, handler);
                },
                registerResizeHandler: function (handler) { return window.addEventListener('resize', handler); },
                deregisterResizeHandler: function (handler) { return window.removeEventListener('resize', handler); },
                updateCssVariable: function (varName, value) {
                    return surfaceEl.setStyle(varName, value);
                },
                computeBoundingRect: function () {
                    return rootEl.ref ? rootEl.ref.getBoundingClientRect() : emptyClientRect;
                },
                getWindowPageOffset: function () { return ({
                    x: window.pageXOffset,
                    y: window.pageYOffset
                }); }
            });
        }
    }), foundation = _a.foundation, elements = __rest(_a, ["foundation"]);
    var rootEl = elements.rootEl;
    var activateRipple = useCallback(function (evt) {
        // https://reactjs.org/docs/events.html#event-pooling
        evt.persist();
        foundation.activate(evt);
    }, [foundation]);
    var deactivateRipple = useCallback(function (evt) {
        // https://reactjs.org/docs/events.html#event-pooling
        evt.persist();
        foundation.deactivate();
    }, [foundation]);
    var handleFocus = useCallback(function (evt) {
        var _a;
        (_a = props.onFocus) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        foundation.handleFocus();
    }, [foundation, props.onFocus]);
    var handleBlur = useCallback(function (evt) {
        var _a;
        (_a = props.onBlur) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        foundation.handleBlur();
    }, [foundation, props.onBlur]);
    var handleMouseDown = useCallback(function (evt) {
        var _a;
        (_a = props.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        if (!isTouched.current) {
            activateRipple(evt);
        }
        isTouched.current = false;
    }, [props.onMouseDown, activateRipple]);
    var handleMouseUp = useCallback(function (evt) {
        var _a;
        (_a = props.onMouseUp) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        deactivateRipple(evt);
    }, [props.onMouseUp, deactivateRipple]);
    var handleTouchStart = useCallback(function (evt) {
        var _a;
        isTouched.current = true;
        (_a = props.onTouchStart) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        activateRipple(evt);
    }, [props.onTouchStart, activateRipple]);
    var handleTouchEnd = useCallback(function (evt) {
        var _a;
        (_a = props.onTouchEnd) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        deactivateRipple(evt);
    }, [props.onTouchEnd, deactivateRipple]);
    var handleKeyDown = useCallback(function (evt) {
        var _a;
        (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        activateRipple(evt);
    }, [props.onKeyDown, activateRipple]);
    var handleKeyUp = useCallback(function (evt) {
        var _a;
        (_a = props.onKeyUp) === null || _a === void 0 ? void 0 : _a.call(props, evt);
        deactivateRipple(evt);
    }, [props.onKeyUp, deactivateRipple]);
    rootEl.setProp('onFocus', handleFocus, true);
    rootEl.setProp('onBlur', handleBlur, true);
    rootEl.setProp('onMouseDown', handleMouseDown, true);
    rootEl.setProp('onMouseUp', handleMouseUp, true);
    rootEl.setProp('onTouchStart', handleTouchStart, true);
    rootEl.setProp('onTouchEnd', handleTouchEnd, true);
    rootEl.setProp('onKeyDown', handleKeyDown, true);
    rootEl.setProp('onKeyUp', handleKeyUp, true);
    useEffect(function () {
        rootEl.setRef(props.domNode);
    }, [rootEl, props.domNode]);
    useEffect(function () {
        foundation.setUnbounded(!!props.unbounded);
    }, [props.unbounded, foundation]);
    useEffect(function () {
        props.disabled && foundation.handleBlur();
    }, [props.disabled, foundation]);
    return __assign({}, elements);
};
