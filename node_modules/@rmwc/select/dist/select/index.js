"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectHelperText = exports.Select = void 0;
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var base_1 = require("@rmwc/base");
var floating_label_1 = require("@rmwc/floating-label");
var line_ripple_1 = require("@rmwc/line-ripple");
var notched_outline_1 = require("@rmwc/notched-outline");
var menu_1 = require("@rmwc/menu");
var list_1 = require("@rmwc/list");
var ripple_1 = require("@rmwc/ripple");
var foundation_1 = require("./foundation");
var select_icon_1 = require("../select-icon");
/**
 * Takes multiple structures for options and returns [{label: 'label', value: 'value', ...rest}]
 */
var createSelectOptions = function (options) {
    // preformatted array
    if (Array.isArray(options) && options[0] && typeof options[0] === 'object') {
        return options.map(function (opt) {
            if (typeof opt !== 'object') {
                throw new Error("Encountered non object for Select " + opt);
            }
            return tslib_1.__assign(tslib_1.__assign({}, opt), { options: createSelectOptions(opt.options) });
        });
    }
    // simple array
    if (Array.isArray(options)) {
        return options.map(function (value) { return ({ value: value, label: value }); });
    }
    // value => label objects
    if (typeof options === 'object') {
        return Object.keys(options).map(function (value) { return ({
            value: value,
            label: options[value]
        }); });
    }
    // default, just return
    return options;
};
var SelectDropdownArrow = react_1.default.memo(function SelectDropdownArrow() {
    return react_1.default.createElement("i", { className: "mdc-select__dropdown-icon" });
});
function NativeMenu(props) {
    var selectOptions = props.selectOptions, _a = props.placeholder, placeholder = _a === void 0 ? '' : _a, children = props.children, elementRef = props.elementRef, rest = tslib_1.__rest(props, ["selectOptions", "placeholder", "children", "elementRef"]);
    var renderOption = function (_a) {
        var label = _a.label, option = _a.option, index = _a.index;
        return (react_1.default.createElement("option", tslib_1.__assign({ key: index }, option, { value: option.value }), label));
    };
    var isEmptyValue = !props.value && !props.defaultValue;
    return (react_1.default.createElement("select", tslib_1.__assign({ tabIndex: 0 }, rest, { ref: elementRef, className: "rmwc-select__native-control " + (rest.className || '') }),
        (props.placeholder !== undefined || isEmptyValue) && (react_1.default.createElement("option", { value: "", disabled: isEmptyValue }, placeholder)),
        !!selectOptions &&
            selectOptions.map(function (_a, index) {
                var label = _a.label, options = _a.options, option = tslib_1.__rest(_a, ["label", "options"]);
                if (options) {
                    return (react_1.default.createElement("optgroup", { label: label, key: index }, options.map(function (_a, index) {
                        var label = _a.label, option = tslib_1.__rest(_a, ["label"]);
                        return renderOption({
                            label: label,
                            option: option,
                            index: index
                        });
                    })));
                }
                return renderOption({
                    label: label,
                    option: option,
                    index: index
                });
            }),
        children));
}
var SelectedTextEl = ripple_1.withRipple({ surface: false })(function (props) {
    return react_1.default.createElement(base_1.Tag, tslib_1.__assign({}, props));
});
function EnhancedMenu(props) {
    var selectOptions = props.selectOptions, menuApiRef = props.menuApiRef, value = props.value, placeholder = props.placeholder, children = props.children, selectedIndex = props.selectedIndex, rest = tslib_1.__rest(props, ["selectOptions", "menuApiRef", "value", "placeholder", "children", "selectedIndex"]);
    var currentIndex = 0;
    var renderOption = function (_a) {
        var label = _a.label, option = _a.option;
        currentIndex += 1;
        return (react_1.default.createElement(menu_1.MenuItem, tslib_1.__assign({ key: label + "-" + option.value, activated: value !== undefined
                ? option.value === value
                : currentIndex - 1 === selectedIndex }, option, { "data-value": option.value }), label));
    };
    return (react_1.default.createElement(menu_1.Menu, tslib_1.__assign({}, rest, { apiRef: menuApiRef, className: "mdc-select__menu", focusOnOpen: true }),
        !!props.placeholder && (react_1.default.createElement(menu_1.MenuItem, { selected: currentIndex - 1 === selectedIndex, "data-value": "", theme: "textDisabledOnBackground" }, placeholder)),
        selectOptions.map(function (_a, i) {
            var label = _a.label, options = _a.options, option = tslib_1.__rest(_a, ["label", "options"]);
            if (options) {
                return (react_1.default.createElement(list_1.ListGroup, { key: i },
                    label && (react_1.default.createElement(list_1.ListGroupSubheader, { theme: "textDisabledOnBackground" }, label)),
                    react_1.default.createElement(menu_1.MenuItems, null, options.map(function (_a) {
                        var label = _a.label, option = tslib_1.__rest(_a, ["label"]);
                        return renderOption({ label: label, option: option });
                    })),
                    i < selectOptions.length - 1 && react_1.default.createElement(list_1.ListDivider, null)));
            }
            return renderOption({ label: label, option: option });
        }),
        children));
}
exports.Select = base_1.createComponent(function Select(props, ref) {
    var placeholder = props.placeholder, children = props.children, value = props.value, outlined = props.outlined, _a = props.label, label = _a === void 0 ? '' : _a, _b = props.options, options = _b === void 0 ? [] : _b, _c = props.rootProps, rootProps = _c === void 0 ? {} : _c, enhanced = props.enhanced, icon = props.icon, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown = props.onKeyDown, invalid = props.invalid, inputRef = props.inputRef, helpText = props.helpText, foundationRef = props.foundationRef, rest = tslib_1.__rest(props, ["placeholder", "children", "value", "outlined", "label", "options", "rootProps", "enhanced", "icon", "onChange", "onFocus", "onBlur", "onKeyDown", "invalid", "inputRef", "helpText", "foundationRef"]);
    var selectOptions = createSelectOptions(options);
    var _d = foundation_1.useSelectFoundation(props), rootEl = _d.rootEl, selectedTextEl = _d.selectedTextEl, notchWidth = _d.notchWidth, menuOpen = _d.menuOpen, selectedTextContent = _d.selectedTextContent, lineRippleActive = _d.lineRippleActive, lineRippleCenter = _d.lineRippleCenter, floatLabel = _d.floatLabel, setFloatingLabel = _d.setFloatingLabel, setNativeControl = _d.setNativeControl, setLeadingIcon = _d.setLeadingIcon, selectedIndex = _d.selectedIndex, setMenu = _d.setMenu, handleFocus = _d.handleFocus, handleBlur = _d.handleBlur, handleClick = _d.handleClick, handleKeydown = _d.handleKeydown, handleMenuClosed = _d.handleMenuClosed, handleMenuOpened = _d.handleMenuOpened, handleMenuSelected = _d.handleMenuSelected;
    var id = base_1.useId('select', props);
    var className = base_1.useClassNames(props, [
        'mdc-select',
        {
            'mdc-select--outlined': !!outlined,
            'mdc-select--required': !!props.required,
            'mdc-select--invalid': !!invalid,
            'mdc-select--with-leading-icon': !!icon,
            'mdc-select--no-label': !label
        }
    ]);
    var enhancedMenuProps = typeof enhanced === 'object' ? enhanced : {};
    var defaultValue = value !== undefined ? undefined : props.defaultValue || '';
    var renderedLabel = (react_1.default.createElement(floating_label_1.FloatingLabel, { float: floatLabel, apiRef: setFloatingLabel, htmlFor: id }, label));
    var renderHelpText = function () {
        var shouldRender = !!helpText;
        if (!shouldRender) {
            return null;
        }
        var shouldSpread = typeof helpText === 'object' && !react_1.default.isValidElement(helpText);
        return helpText && shouldSpread ? (react_1.default.createElement(exports.SelectHelperText, tslib_1.__assign({}, helpText))) : (react_1.default.createElement(exports.SelectHelperText, null, helpText));
    };
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(base_1.Tag, tslib_1.__assign({ role: "listbox" }, rootProps, { element: rootEl, ref: ref, className: className }),
            react_1.default.createElement("div", { className: "mdc-select__anchor" },
                !!icon && react_1.default.createElement(select_icon_1.SelectIcon, { apiRef: setLeadingIcon, icon: icon }),
                react_1.default.createElement(SelectDropdownArrow, null),
                react_1.default.createElement(SelectedTextEl, { className: "mdc-select__selected-text", role: "button", "aria-haspopup": "listbox", element: selectedTextEl, onFocus: handleFocus, onBlur: handleBlur, onClick: handleClick, onKeyDown: handleKeydown, 
                    /** In the case of native selects, we don't want this to be be focusable */
                    tabIndex: enhanced ? undefined : -1 }, selectedTextContent || react_1.default.createElement(react_1.default.Fragment, null, "\u00A0")),
                outlined ? (react_1.default.createElement(notched_outline_1.NotchedOutline, { notch: notchWidth }, renderedLabel)) : (react_1.default.createElement(react_1.default.Fragment, null,
                    renderedLabel,
                    react_1.default.createElement(line_ripple_1.LineRipple, { active: lineRippleActive, center: lineRippleCenter }))),
                !enhanced && (react_1.default.createElement(NativeMenu, tslib_1.__assign({}, rest, { value: value, children: children, defaultValue: defaultValue, placeholder: placeholder, selectOptions: selectOptions, elementRef: setNativeControl, onFocus: handleFocus, onBlur: handleBlur, onChange: function (evt) {
                        return handleMenuSelected(evt.currentTarget.selectedIndex);
                    } })))),
            enhanced && (react_1.default.createElement(EnhancedMenu, tslib_1.__assign({}, rest, enhancedMenuProps, { anchorCorner: "bottomStart", defaultValue: defaultValue, placeholder: placeholder, open: menuOpen, onClose: handleMenuClosed, onOpen: handleMenuOpened, onSelect: function (evt) {
                    handleMenuSelected(evt.detail.index);
                }, selectOptions: selectOptions, value: value, selectedIndex: selectedIndex, menuApiRef: setMenu, children: children })))),
        renderHelpText()));
});
/** A help text component */
exports.SelectHelperText = base_1.createComponent(function SelectHelperText(props, ref) {
    var persistent = props.persistent, validationMsg = props.validationMsg, rest = tslib_1.__rest(props, ["persistent", "validationMsg"]);
    var className = base_1.useClassNames(props, [
        'mdc-select-helper-text',
        {
            'mdc-select-helper-text--persistent': persistent,
            'mdc-select-helper-text--validation-msg': validationMsg
        }
    ]);
    return react_1.default.createElement(base_1.Tag, tslib_1.__assign({ tag: "p" }, rest, { className: className, ref: ref }));
});
