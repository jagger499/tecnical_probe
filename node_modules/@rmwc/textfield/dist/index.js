"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextFieldHelperText = exports.TextField = void 0;
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var base_1 = require("@rmwc/base");
var icon_1 = require("@rmwc/icon");
var line_ripple_1 = require("@rmwc/line-ripple");
var floating_label_1 = require("@rmwc/floating-label");
var notched_outline_1 = require("@rmwc/notched-outline");
var ripple_1 = require("@rmwc/ripple");
var textfield_icon_foundation_1 = require("./textfield-icon-foundation");
var textfield_character_count_foundation_1 = require("./textfield-character-count-foundation");
var textfield_foundation_1 = require("./textfield-foundation");
/** A TextField component for accepting text input from a user. */
exports.TextField = base_1.createComponent(function TextField(props, ref) {
    var label = props.label, style = props.style, outlined = props.outlined, align = props.align, fullwidth = props.fullwidth, invalid = props.invalid, disabled = props.disabled, helpText = props.helpText, children = props.children, textarea = props.textarea, inputRef = props.inputRef, characterCount = props.characterCount, icon = props.icon, trailingIcon = props.trailingIcon, _a = props.rootProps, rootProps = _a === void 0 ? {} : _a, foundationRef = props.foundationRef, ripple = props.ripple, userFloatLabel = props.floatLabel, rest = tslib_1.__rest(props, ["label", "style", "outlined", "align", "fullwidth", "invalid", "disabled", "helpText", "children", "textarea", "inputRef", "characterCount", "icon", "trailingIcon", "rootProps", "foundationRef", "ripple", "floatLabel"]);
    var _b = textfield_foundation_1.useTextFieldFoundation(props), rootEl = _b.rootEl, inputEl = _b.inputEl, shakeLabel = _b.shakeLabel, floatLabel = _b.floatLabel, notchWidth = _b.notchWidth, lineRippleActive = _b.lineRippleActive, lineRippleCenter = _b.lineRippleCenter, setLeadingIcon = _b.setLeadingIcon, setTrailingIcon = _b.setTrailingIcon, setFloatingLabel = _b.setFloatingLabel, setCharacterCounter = _b.setCharacterCounter;
    var id = base_1.useId('textfield', props);
    var labelId = id + '-label';
    var className = base_1.useClassNames(props, [
        'mdc-text-field',
        'mdc-text-field--upgraded',
        {
            'mdc-text-field--textarea': textarea,
            'mdc-text-field--fullwidth': fullwidth,
            'mdc-text-field--outlined': outlined,
            'mdc-text-field--invalid': invalid,
            'mdc-text-field--disabled': disabled,
            'mdc-text-field--with-leading-icon': !!icon,
            'mdc-text-field--with-trailing-icon': !!trailingIcon,
            'mdc-text-field--no-label': !label,
            'mdc-text-field--end-aligned': align === 'end'
        }
    ]);
    // handle leading and trailing icons
    var renderIcon = function (icon, position) {
        return (react_1.default.createElement(TextFieldIcon, { apiRef: function (api) {
                position === 'leading' ? setLeadingIcon(api) : setTrailingIcon(api);
            }, position: position, tabIndex: position === 'trailing' ? 0 : undefined, icon: icon }));
    };
    var renderHelpText = function (renderedCharacterCounter) {
        var shouldRender = !!helpText || (characterCount && !textarea);
        if (!shouldRender) {
            return null;
        }
        var shouldSpread = typeof helpText === 'object' && !react_1.default.isValidElement(helpText);
        return (react_1.default.createElement("div", { className: "mdc-text-field-helper-line" },
            helpText && shouldSpread ? (react_1.default.createElement(exports.TextFieldHelperText, tslib_1.__assign({}, helpText))) : (react_1.default.createElement(exports.TextFieldHelperText, null, helpText)),
            !textarea && renderedCharacterCounter));
    };
    var renderedLabel = label ? (react_1.default.createElement(floating_label_1.FloatingLabel, { shake: shakeLabel, float: floatLabel, apiRef: setFloatingLabel, id: labelId }, label)) : null;
    var renderedCharacterCounter = characterCount ? (react_1.default.createElement(TextFieldCharacterCount, { apiRef: setCharacterCounter })) : null;
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(TextFieldRoot, tslib_1.__assign({}, rootProps, { element: rootEl, style: style, className: className, ref: ref, "aria-labelledby": labelId }),
            !!icon && renderIcon(icon, 'leading'),
            children,
            !!textarea && renderedCharacterCounter,
            react_1.default.createElement(TextFieldRipple, null),
            react_1.default.createElement(base_1.Tag, tslib_1.__assign({}, rest, { element: inputEl, className: "mdc-text-field__input", disabled: disabled, tag: textarea ? 'textarea' : 'input', ref: inputRef })),
            !!outlined ? (react_1.default.createElement(react_1.default.Fragment, null,
                react_1.default.createElement(notched_outline_1.NotchedOutline, { notch: notchWidth }, renderedLabel),
                !!trailingIcon && renderIcon(trailingIcon, 'trailing'))) : (react_1.default.createElement(react_1.default.Fragment, null,
                renderedLabel,
                !!trailingIcon && renderIcon(trailingIcon, 'trailing'),
                react_1.default.createElement(line_ripple_1.LineRipple, { active: lineRippleActive, center: lineRippleCenter })))),
        renderHelpText(renderedCharacterCounter)));
});
var TextFieldRipple = react_1.default.memo(function TextFieldRipple() {
    return react_1.default.createElement("span", { className: "mdc-text-field__ripple" });
});
var TextFieldRoot = ripple_1.withRipple({ surface: false })(react_1.default.forwardRef(function TextFieldRoot(props, ref) {
    return react_1.default.createElement(base_1.Tag, tslib_1.__assign({}, props, { tag: "label", ref: ref }));
}));
var TextFieldCharacterCount = react_1.default.memo(function TextFieldCharacterCount(props) {
    var content = textfield_character_count_foundation_1.useTextFieldCharacterCountFoundation(props).content;
    return react_1.default.createElement("div", { className: "mdc-text-field-character-counter" }, content);
});
/** A help text component */
exports.TextFieldHelperText = base_1.createComponent(function TextFieldHelperText(props, ref) {
    var persistent = props.persistent, validationMsg = props.validationMsg, rest = tslib_1.__rest(props, ["persistent", "validationMsg"]);
    var className = base_1.useClassNames(props, [
        'mdc-text-field-helper-text',
        {
            'mdc-text-field-helper-text--persistent': persistent,
            'mdc-text-field-helper-text--validation-msg': validationMsg
        }
    ]);
    return react_1.default.createElement(base_1.Tag, tslib_1.__assign({ tag: "p" }, rest, { className: className, ref: ref }));
});
/** An Icon in a TextField */
var TextFieldIcon = function TextFieldIcon(props) {
    var apiRef = props.apiRef, position = props.position, rest = tslib_1.__rest(props, ["apiRef", "position"]);
    var rootEl = textfield_icon_foundation_1.useTextFieldIconFoundation(props).rootEl;
    var className = base_1.useClassNames(props, [
        'mdc-text-field__icon',
        {
            'mdc-text-field__icon--trailing': position === 'trailing',
            'mdc-text-field__icon--leading': position === 'leading'
        }
    ]);
    return (react_1.default.createElement(icon_1.Icon, tslib_1.__assign({}, rootEl.props(tslib_1.__assign(tslib_1.__assign({}, rest), { className: className })))));
};
TextFieldIcon.displayName = 'TextFieldIcon';
